;+
; NAME:
;   LONG_SLIT_HANDMOD
;
;
; PURPOSE:
;   Make direct modifications to existing slit file generated by
;   LONG_REDUCE/LONG_SLITMASK. Takes as input either a FITS file that
;   tells the code explicitly the edge positions for the slit edges that
;   are to be modified.  
;
;   More flexible than the EDIT_SEDGE_FIL keyword in LONG_SLITMASK as
;   we fully specify the full [x,y] positions of the slit edges we
;   wish to modify.
;
;
; CALLING SEQUENCE:
;   long_slit_handmod, modfile, [slit_in, outfil==outfil,
;     img_out=img_out, tset_out=tset_out,  func=func, 
;     ncoeff=ncoeff ny=ny, nx=nx]
;
;
; INPUTS:
;  MODFILE          - Input file containing a structure with the form
;                     {slit_handmod, slitid:0L,lr_flag:0.,
;                     x_edge:replicate(0.,2048)}. slitid start with 1,
;                     lr_flat=0 for left and =1 for right, while
;                     x_edge needs to be matched to the y-positions
;                     from TRACESET2XY  
;
;
; OPTIONAL INPUTS:
;  OUTFIL           - Output filename. If not set, output filename
;                     will be input file name appended with
;                     '_mod'. Output file is in FITS format with the
;                     slitmask image in HDU0 and the traceset in HDU1
;  SLIT_IN          - Slits file as created by LONG_REDUCE. If not
;                     specified, will look in local directory
;                     for 'slits*.fits*'
;  NX               - Number of x-pixels
;  NY               - Number of y-pixels
;
;
; KEYWORD PARAMETERS:
;
;
;
; OUTPUTS:
;
;
;
; OPTIONAL OUTPUTS:
;  IMG_OUT          - Output slit mask image
;  TSET_OUT         - Output traceset
;
;
; COMMON BLOCKS:
;
;
;
; BUGS/SIDE EFFECTS:
;   - Unlike LONG_SLITMASK, we don't use the flats to create
;     IVAR, so there's no weighting in generating the new
;     traces. The output trace sets also therefore do not have the
;     XCORR_COEFF tags 
;
;
; PROCEDURE:
;
;
;
; EXAMPLE:
;
;
;
; MODIFICATION HISTORY:
;  KG Lee  22.07.2014   - Original code
;-

PRO LONG_SLIT_HANDMOD, modfil, slit_in, outfil=outfil, img_out=img_out, $
     tset_out=tset_out, func=func, ncoeff=ncoeff, ny=ny, nx=nx

if not keyword_set(nx) then nx = 2048L
if not keyword_set(ny) then ny = 2048L

dims = [nx,ny]

if not keyword_set(slit_in) then begin
   slit_in = findfile('slit*fits*', count=nfil)
   if nfil EQ 0 then begin
      print, 'Error: must specify slit file in local directory'
      stop
   endif else $
      print, 'No slit file specified. Found '+strtrim(slit_in[0],2)+ $
             ' so will use that.'
endif

if not keyword_set(modfil) then begin
   print, 'Error: Please enter input file with slit modifications'
   stop
endif

modstruct = mrdfits(modfil,1)
nmod = n_elements(modstruct)

slit_in = slit_in[0]
img_orig = xmrdfits(slit_in,0,hdr, /silent)
tset_in = xmrdfits(slit_in, 1,/silent)

traceset2xy, tset_in[0], rows, left_edge
traceset2xy, tset_in[1], rows, right_edge

for imod=0, nmod-1 do begin
   mod_tmp = modstruct[imod]   
   ind_slit= mod_tmp.slitid -1
   
   IF mod_tmp.lr_flag EQ 0 then begin
      left_edge[*,ind_slit] = mod_tmp.x_edge
   endif else if mod_tmp.lr_flag EQ 1 then begin
      right_edge[*,ind_slit] = mod_tmp.x_edge
   endif

endfor

; We assume the same xmin and xmax as for the original slit traceset 
xy2traceset, rows, left_edge, tset_out1, xmin=tset_in[0].xmin, $
             xmax = tset_in[0].xmax, func=func, ncoeff=ncoeff
xy2traceset, rows, right_edge, tset_out2, xmin=tset_in[1].xmin, $
             xmax = tset_in[1].xmax, func=func, ncoeff=ncoeff

tset_out = [tset_out1, tset_out2]
tset_out = struct_addtags(tset_out $
                          , replicate(create_struct('DIMS', dims) $
                                      , size(tset_out, /dimens)))

img_out= long_slits2mask(tset_out)

if not keyword_set(outfil) then $
   outfil = (strsplit(slit_in, '.',/extract))[0]+'_mod.fits'

print, 'Writing to ', outfil
mwrfits, img_out, outfil, hdr, /create, /silent
mwrfits, tset_out, outfil, /silent

end
